<!DOCTYPE html>
<!-- æ¸¦å·»ããƒ‘ã‚¤ãƒ—ãƒ‘ã‚ºãƒ« v007 - æ¶ˆæ»…ä¸­æ“ä½œæ”¹å–„ãƒ»éç ´å£Šçš„è¨­å®šå¤‰æ›´ç‰ˆ -->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¸¦å·»ããƒ‘ã‚¤ãƒ—ãƒ‘ã‚ºãƒ«</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            text-align: center;
            overflow: hidden;
        }

        .game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .top-bar {
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            height: 25px;
            z-index: 10;
        }
        
        .controls-container {
            position: absolute;
            top: 5px;
            right: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 10;
        }
        
        .score-display {
            font-size: 18px;
        }
        
        .high-score {
            font-size: 14px;
            color: #FFD700;
            margin-left: 15px;
        }
        
        .game-board-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 35px 5px 15px 5px;
        }
        
        .game-board {
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 2px;
        }
        
        .cell {
            display: inline-block;
            background: #111;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .cell:hover {
            background: #333;
        }
        
        /* æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚«ãƒ¼ã‚½ãƒ«å¤‰æ›´ */
        .cell.disappearing {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .pipe {
            width: 100%;
            height: 100%;
            position: relative;
            background: linear-gradient(145deg, #555, #333);
            border-radius: 3px;
            transition: filter 0.8s ease-in-out, box-shadow 0.8s ease-in-out;
        }
        
        .pipe::before,
        .pipe::after {
            content: '';
            position: absolute;
            background: linear-gradient(145deg, #6CAF70, #4A7C59);
            border-radius: 3px;
            transition: background 0.8s ease-in-out;
        }
        
        /* 10æ®µéšè‰²åˆ†ã‘ï¼ˆæ»‘ã‚‰ã‹ãªå¤‰åŒ–ã€10ä»¥ä¸Šã¯æ˜ã‚‹ã•ã§åŒºåˆ¥ï¼‰ */
        .pipe.path-0::before, .pipe.path-0::after { 
            background: linear-gradient(145deg, #FF0000, #E60000); /* èµ¤ - 1å€‹ */
        }
        .pipe.path-1::before, .pipe.path-1::after { 
            background: linear-gradient(145deg, #FF4000, #E63A00); /* èµ¤ã‚ªãƒ¬ãƒ³ã‚¸ - 2å€‹ */
        }
        .pipe.path-2::before, .pipe.path-2::after { 
            background: linear-gradient(145deg, #FF8000, #E67300); /* ã‚ªãƒ¬ãƒ³ã‚¸ - 3å€‹ */
        }
        .pipe.path-3::before, .pipe.path-3::after { 
            background: linear-gradient(145deg, #FFBF00, #E6AC00); /* é»„ã‚ªãƒ¬ãƒ³ã‚¸ - 4å€‹ */
        }
        .pipe.path-4::before, .pipe.path-4::after { 
            background: linear-gradient(145deg, #FFFF00, #E6E600); /* é»„ - 5å€‹ */
        }
        .pipe.path-5::before, .pipe.path-5::after { 
            background: linear-gradient(145deg, #80FF00, #73E600); /* é»„ç·‘ - 6å€‹ */
        }
        .pipe.path-6::before, .pipe.path-6::after { 
            background: linear-gradient(145deg, #00FF00, #00E600); /* ç·‘ - 7å€‹ */
        }
        .pipe.path-7::before, .pipe.path-7::after { 
            background: linear-gradient(145deg, #00FF80, #00E673); /* ç·‘é’ - 8å€‹ */
        }
        .pipe.path-8::before, .pipe.path-8::after { 
            background: linear-gradient(145deg, #0080FF, #0073E6); /* é’ - 9å€‹ */
        }
        .pipe.path-9::before, .pipe.path-9::after { 
            background: linear-gradient(145deg, #8000FF, #7300E6); /* ç´« - 10å€‹ */
        }
        
        /* 10å€‹ä»¥ä¸Šã®æ˜ã‚‹ã•åŒºåˆ¥ */
        .pipe.length-10plus {
            filter: brightness(1.4) saturate(1.4);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
        }
        
        /* Iå­—ãƒ‘ã‚¤ãƒ— */
        .pipe-I.rot-0::before {
            left: 35%;
            top: 0%;
            width: 30%;
            height: 100%;
        }
        
        .pipe-I.rot-1::before {
            left: 0%;
            top: 35%;
            width: 100%;
            height: 30%;
        }
        
        /* Lå­—ãƒ‘ã‚¤ãƒ— */
        .pipe-L.rot-0::before {
            left: 35%;
            top: 35%;
            width: 65%;
            height: 30%;
        }
        .pipe-L.rot-0::after {
            left: 35%;
            top: 35%;
            width: 30%;
            height: 65%;
        }
        
        .pipe-L.rot-1::before {
            left: 0%;
            top: 35%;
            width: 65%;
            height: 30%;
        }
        .pipe-L.rot-1::after {
            left: 35%;
            top: 35%;
            width: 30%;
            height: 65%;
        }
        
        .pipe-L.rot-2::before {
            left: 0%;
            top: 35%;
            width: 65%;
            height: 30%;
        }
        .pipe-L.rot-2::after {
            left: 35%;
            top: 0%;
            width: 30%;
            height: 65%;
        }
        
        .pipe-L.rot-3::before {
            left: 35%;
            top: 35%;
            width: 65%;
            height: 30%;
        }
        .pipe-L.rot-3::after {
            left: 35%;
            top: 0%;
            width: 30%;
            height: 65%;
        }
        
        /* ãƒ«ãƒ¼ãƒ—æ¤œå‡ºæ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .loop-highlight {
            animation: loopPulse 0.6s ease-in-out;
            background: linear-gradient(145deg, #FFD700, #FF8C00) !important;
            transform: scale(1.1);
            z-index: 5;
            position: relative;
        }
        
        @keyframes loopPulse {
            0%, 100% { 
                transform: scale(1.1); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% { 
                transform: scale(1.2); 
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }
        }
        
        /* ãƒ–ãƒ­ãƒƒã‚¯æ¶ˆæ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ - ã‚†ã£ãã‚Šæ¶ˆæ»… */
        .block-disappear {
            animation: disappear 1.2s ease-in-out forwards;
        }
        
        @keyframes disappear {
            0% { 
                transform: scale(1.1); 
                opacity: 1;
            }
            20% { 
                transform: scale(1.3) rotate(5deg); 
                opacity: 0.9;
            }
            60% { 
                transform: scale(1.1) rotate(15deg); 
                opacity: 0.5;
            }
            100% { 
                transform: scale(0) rotate(90deg); 
                opacity: 0;
            }
        }
        
        /* ã‚¹ã‚³ã‚¢ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
        .score-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: scorePopup 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        
        @keyframes scorePopup {
            0% { 
                transform: translate(-50%, -50%) scale(0.5); 
                opacity: 1;
            }
            20% { 
                transform: translate(-50%, -50%) scale(1.2); 
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -100%) scale(1); 
                opacity: 0;
            }
        }
        
        button {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        select {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .game-over-content {
            background: #333;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
        }
        
        /* è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .settings-content {
            background: #333;
            padding: 30px;
            border-radius: 12px;
            min-width: 300px;
            max-width: 400px;
            color: white;
        }
        
        .settings-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #ccc;
        }
        
        .field-size-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .size-option {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 4px;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .size-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .size-option.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .speed-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }
        
        .speed-option {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 4px;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .speed-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .speed-option.selected {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        
        .settings-option label {
            font-size: 14px;
        }
        
        .settings-option input[type="checkbox"] {
            transform: scale(1.2);
        }
        
        .settings-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .settings-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            min-width: 70px;
        }
        
        .settings-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .settings-btn.primary {
            background: #4CAF50;
            border-color: #45a049;
        }
        
        .settings-btn.primary:hover {
            background: #45a049;
        }
        
        .reset-btn {
            background: #FF6B6B;
            border-color: #FF5252;
        }
        
        .reset-btn:hover {
            background: #FF5252;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="top-bar">
            <div class="score-display">
                ã‚¹ã‚³ã‚¢: <span id="score">0</span>
                <span class="high-score">æœ€é«˜: <span id="highScore">0</span></span>
            </div>

            <div class="controls-container">
                <button onclick="openSettings()" id="settingsBtn">âš™ï¸</button>
                <button onclick="togglePause()" id="pauseBtn">â¸ï¸</button>
                <button onclick="newGame()">ğŸ”„</button>
            </div>
        </div>
        
        <div class="game-board-container">
            <div class="game-board" id="gameBoard"></div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</h2>
            <p>ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
            <button onclick="newGame()">ã‚‚ã†ä¸€åº¦</button>
        </div>
    </div>

    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-title">è¨­å®š</div>
            
            <div class="settings-section">
                <h4>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚º</h4>
                <div class="field-size-grid">
                    <div class="size-option" data-size="5">5Ã—5</div>
                    <div class="size-option" data-size="7">7Ã—7</div>
                    <div class="size-option" data-size="9">9Ã—9</div>
                    <div class="size-option selected" data-size="11">11Ã—11</div>
                    <div class="size-option" data-size="13">13Ã—13</div>
                    <div class="size-option" data-size="15">15Ã—15</div>
                    <div class="size-option" data-size="17">17Ã—17</div>
                    <div class="size-option" data-size="19">19Ã—19</div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4>ã‚²ãƒ¼ãƒ é€Ÿåº¦</h4>
                <div class="speed-grid">
                    <div class="speed-option" data-speed="0.5">0.5x</div>
                    <div class="speed-option selected" data-speed="1">1x</div>
                    <div class="speed-option" data-speed="1.5">1.5x</div>
                    <div class="speed-option" data-speed="2">2x</div>
                    <div class="speed-option" data-speed="4">4x</div>
                </div>
            </div>
            
            <div class="settings-section">
                <h4>ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š</h4>
                <div class="settings-option">
                    <label>ã‚µã‚¦ãƒ³ãƒ‰åŠ¹æœ</label>
                    <input type="checkbox" id="soundEffects" checked>
                </div>
                <div class="settings-option">
                    <label>BGM</label>
                    <input type="checkbox" id="backgroundMusic">
                </div>
            </div>
            
            <div class="settings-section">
                <h4>è¨˜éŒ²</h4>
                <div class="settings-option">
                    <label>ãƒã‚¤ã‚¹ã‚³ã‚¢: <span id="settingsHighScore">0</span></label>
                    <button class="settings-btn reset-btn" onclick="resetHighScore()">ãƒªã‚»ãƒƒãƒˆ</button>
                </div>
            </div>
            
            <div class="settings-buttons">
                <button class="settings-btn" onclick="closeSettings()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="settings-btn primary" onclick="applySettings()">é©ç”¨</button>
            </div>
        </div>
    </div>

    <script>
        let game = null;
        let tempSettings = {
            fieldSize: 11,
            gameSpeed: 1,
            soundEffects: true,
            backgroundMusic: false
        };
        
        // ãƒã‚¤ã‚¹ã‚³ã‚¢ç®¡ç†
        class HighScoreManager {
            constructor() {
                this.storageKey = 'pipeHighScore';
            }
            
            getHighScore() {
                return parseInt(localStorage.getItem(this.storageKey) || '0');
            }
            
            setHighScore(score) {
                const currentHigh = this.getHighScore();
                if (score > currentHigh) {
                    localStorage.setItem(this.storageKey, score.toString());
                    return true; // æ–°è¨˜éŒ²
                }
                return false;
            }
            
            resetHighScore() {
                localStorage.removeItem(this.storageKey);
                this.updateHighScoreDisplay();
            }
            
            updateHighScoreDisplay() {
                const highScore = this.getHighScore();
                const highScoreEl = document.getElementById('highScore');
                const settingsHighScoreEl = document.getElementById('settingsHighScore');
                if (highScoreEl) highScoreEl.textContent = highScore;
                if (settingsHighScoreEl) settingsHighScoreEl.textContent = highScore;
            }
        }
        
        // ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
        class SoundManager {
            constructor() {
                this.enabled = true;
                this.musicEnabled = false;
                this.audioContext = null;
                this.bgmGain = null;
                this.initAudio();
            }
            
            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.bgmGain = this.audioContext.createGain();
                    this.bgmGain.connect(this.audioContext.destination);
                    this.emergencyBeepInterval = null;
                } catch (error) {
                    console.log('Web Audio API not supported, using fallback');
                }
            }
            
            // ãƒ‘ã‚¤ãƒ—å›è»¢éŸ³ï¼ˆãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºï¼‰
            playRotateSound() {
                if (!this.enabled) return;
                this.playWhiteNoise(0.05, 0.03); // çŸ­ãã€å°ã•ã
            }
            
            // ãƒ«ãƒ¼ãƒ—å®ŒæˆéŸ³ï¼ˆå€éŸ³å®Ÿé¨“ï¼‰- 150msé–“éš”ã«èª¿æ•´
            playLoopCompleteSound(loopLength) {
                if (!this.enabled) return;
                
                // å€éŸ³ã‚·ãƒªãƒ¼ã‚ºå®Ÿé¨“: åŸºéŸ³200Hzã‹ã‚‰å€éŸ³ã‚’ç”Ÿæˆ
                const baseFreq = 200;
                const harmonics = Math.min(loopLength, 16); // æœ€å¤§16å€éŸ³ã¾ã§
                
                for (let i = 1; i <= harmonics; i++) {
                    const freq = baseFreq * i;
                    const volume = 0.1 / Math.sqrt(i); // é«˜æ¬¡å€éŸ³ã¯éŸ³é‡ã‚’æ¸›è¡°
                    setTimeout(() => {
                        this.playTone(freq, 0.3, volume);
                    }, (i - 1) * 150); // âœ… 150msé–“éš”ã«èª¿æ•´ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¨åŒæœŸï¼‰
                }
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯å‡ºç¾éŸ³ï¼ˆæœ¨é­šãƒªã‚ºãƒ ï¼‰
            playBlockAppearSound() {
                if (!this.enabled) return;
                // æœ¨é­šã®ã‚ˆã†ãªä½ãçŸ­ã„éŸ³
                this.playTone(150, 0.1, 0.03);
            }
            
            // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰è­¦å‘ŠéŸ³ï¼ˆç¶™ç¶šéŸ³ï¼‰
            playEmergencySound() {
                if (!this.enabled) return;
                this.startContinuousEmergencySound();
            }
            
            startContinuousEmergencySound() {
                // æ—¢å­˜ã®ç·Šæ€¥éŸ³ã‚’ã‚¯ãƒªã‚¢
                if (this.emergencyBeepInterval) {
                    clearInterval(this.emergencyBeepInterval);
                }
                
                // ç¶™ç¶šçš„ãªè­¦å‘ŠéŸ³
                this.emergencyBeepInterval = setInterval(() => {
                    if (!this.enabled) return;
                    this.playTone(880, 0.2, 0.06);
                    setTimeout(() => this.playTone(440, 0.2, 0.06), 250);
                }, 800);
            }
            
            stopEmergencySound() {
                if (this.emergencyBeepInterval) {
                    clearInterval(this.emergencyBeepInterval);
                    this.emergencyBeepInterval = null;
                }
            }
            
            // ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºç”Ÿæˆ
            playWhiteNoise(duration, volume = 0.1) {
                if (!this.audioContext) {
                    console.log(`ğŸ”Š ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºå†ç”Ÿï¼ˆä»£æ›¿ï¼‰: ${duration}s`);
                    return;
                }
                
                try {
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºç”Ÿæˆ
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * volume;
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    
                    source.buffer = buffer;
                    source.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ãƒ»ã‚¢ã‚¦ãƒˆ
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(1, this.audioContext.currentTime + 0.005);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    
                    source.start(this.audioContext.currentTime);
                    source.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.log(`ğŸ”Š ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çˆ†ç™ºéŸ³
            playGameOverSound() {
                if (!this.enabled) return;
                
                // çˆ†ç™ºéŸ³ï¼šè¤‡æ•°ã®ä½å‘¨æ³¢ã‚’é‡ã­ã‚‹ + ãƒã‚¤ã‚º
                const frequencies = [60, 80, 120, 150, 200];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        this.playTone(freq, 1.0, 0.12);
                    }, i * 30);
                });
                
                // ãƒã‚¤ã‚ºæˆåˆ†ã‚’è¿½åŠ 
                setTimeout(() => {
                    this.playWhiteNoise(0.8, 0.08);
                }, 100);
            }
            
            // åŸºæœ¬ãƒˆãƒ¼ãƒ³å†ç”Ÿ
            playTone(frequency, duration, volume = 0.1) {
                if (!this.audioContext) {
                    console.log(`ğŸ”Š éŸ³å†ç”Ÿï¼ˆä»£æ›¿ï¼‰: ${frequency}Hz, ${duration}s`);
                    return;
                }
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (error) {
                    console.log(`ğŸ”Š éŸ³å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            // BGMé–‹å§‹/åœæ­¢
            toggleMusic() {
                if (!this.musicEnabled) return;
                console.log('ğŸµ BGMåˆ‡ã‚Šæ›¿ãˆï¼ˆæœªå®Ÿè£…ï¼‰');
                // TODO: å®Ÿéš›ã®BGMãƒ•ã‚¡ã‚¤ãƒ«å†ç”Ÿ
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                console.log(`ğŸ”Š ã‚µã‚¦ãƒ³ãƒ‰åŠ¹æœ: ${enabled ? 'ON' : 'OFF'}`);
            }
            
            setMusicEnabled(enabled) {
                this.musicEnabled = enabled;
                console.log(`ğŸµ BGM: ${enabled ? 'ON' : 'OFF'}`);
                this.toggleMusic();
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        const highScoreManager = new HighScoreManager();
        const soundManager = new SoundManager();
        
        class Game {
            constructor() {
                this.size = 11; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚º11Ã—11
                this.board = [];
                this.score = 0;
                this.running = false;
                this.paused = false;
                
                // âœ… v007: æ¶ˆæ»…ä¸­æ“ä½œæ”¹å–„ã‚·ã‚¹ãƒ†ãƒ 
                this.canGenerateBlocks = true; // ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆå¯èƒ½ãƒ•ãƒ©ã‚°
                this.disappearingBlocks = new Set(); // æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯ã®åº§æ¨™ç®¡ç†
                
                this.timerInterval = null;
                this.emergencyMode = false;
                this.emergencyTimer = 20;
                this.speedMultiplier = 1;
                
                // ãƒ•ãƒªãƒƒã‚¯æ“ä½œç”¨
                this.touchStartX = 0;
                this.touchStartY = 0;
                
                this.init();
            }
            
            init() {
                this.board = [];
                for (let i = 0; i < this.size; i++) {
                    this.board[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.board[i][j] = null;
                    }
                }
                this.render();
                highScoreManager.updateHighScoreDisplay();
            }
            
            render() {
                const board = document.getElementById('gameBoard');
                if (!board) return;
                
                board.innerHTML = '';
                board.style.display = 'grid';
                board.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
                board.style.gap = '0';
                
                const availableHeight = window.innerHeight - 70;
                const availableWidth = window.innerWidth - 20;
                const maxSize = Math.min(availableWidth, availableHeight);
                
                const cellSize = Math.floor(maxSize / this.size);
                const boardSize = cellSize * this.size;
                
                board.style.width = `${boardSize}px`;
                board.style.height = `${boardSize}px`;
                board.style.position = 'relative';
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.style.width = `${cellSize}px`;
                        cell.style.height = `${cellSize}px`;
                        cell.style.boxSizing = 'border-box';
                        
                        // âœ… v007: æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯è¦–è¦šè¡¨ç¤º
                        const cellKey = `${i},${j}`;
                        if (this.disappearingBlocks.has(cellKey)) {
                            cell.classList.add('disappearing');
                        }
                        
                        cell.onclick = () => this.clickCell(i, j);
                        
                        cell.classList.remove('loop-highlight', 'block-disappear');
                        
                        cell.addEventListener('touchstart', (e) => this.handleTouchStart(e, i, j));
                        cell.addEventListener('touchend', (e) => this.handleTouchEnd(e, i, j));
                        cell.addEventListener('touchmove', (e) => e.preventDefault());
                        
                        if (this.board[i][j]) {
                            const pipe = document.createElement('div');
                            
                            // ãƒ‘ã‚¹è‰²ã‚¯ãƒ©ã‚¹ã¨æ˜ã‚‹ã•ã‚¯ãƒ©ã‚¹ã‚’å–å¾—
                            const pathColor = this.board[i][j].pathColor !== undefined ? `path-${this.board[i][j].pathColor}` : '';
                            const lengthClass = this.board[i][j].lengthClass || '';
                            
                            pipe.className = `pipe pipe-${this.board[i][j].type} rot-${this.board[i][j].rotation} ${pathColor} ${lengthClass}`.trim();
                            cell.appendChild(pipe);
                        }
                        
                        board.appendChild(cell);
                    }
                }
                
                const scoreEl = document.getElementById('score');
                if (scoreEl) scoreEl.textContent = this.score;
            }
            
            handleTouchStart(e, row, col) {
                e.preventDefault();
                const touch = e.touches[0];
                this.touchStartX = touch.clientX;
                this.touchStartY = touch.clientY;
            }
            
            handleTouchEnd(e, row, col) {
                e.preventDefault();
                if (!this.running || this.paused) return;
                if (!this.board[row][col]) return;
                
                // âœ… v007: æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯å€‹åˆ¥ãƒã‚§ãƒƒã‚¯
                const cellKey = `${row},${col}`;
                if (this.disappearingBlocks.has(cellKey)) return;
                
                const touch = e.changedTouches[0];
                const deltaX = touch.clientX - this.touchStartX;
                const deltaY = touch.clientY - this.touchStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance < 30) {
                    this.clickCell(row, col);
                    return;
                }
                
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                this.handleFlick(row, col, angle);
            }
            
            handleFlick(row, col, angle) {
                if (!this.board[row][col]) return;
                
                // âœ… v007: æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯å€‹åˆ¥ãƒã‚§ãƒƒã‚¯
                const cellKey = `${row},${col}`;
                if (this.disappearingBlocks.has(cellKey)) return;
                
                const pipeType = this.board[row][col].type;
                
                if (pipeType === 'I') {
                    if ((angle >= -45 && angle <= 45) || (angle >= 135 || angle <= -135)) {
                        this.board[row][col].rotation = 1;
                    } else {
                        this.board[row][col].rotation = 0;
                    }
                } else if (pipeType === 'L') {
                    let targetRotation;
                    if (angle >= 22.5 && angle < 67.5) {
                        targetRotation = 0;
                    } else if (angle >= 112.5 && angle < 157.5) {
                        targetRotation = 1;
                    } else if (angle >= -157.5 && angle < -112.5) {
                        targetRotation = 2;
                    } else if (angle >= -67.5 && angle < -22.5) {
                        targetRotation = 3;
                    } else {
                        this.clickCell(row, col);
                        return;
                    }
                    this.board[row][col].rotation = targetRotation;
                }
                
                // ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
                soundManager.playRotateSound();
                
                this.updatePathColors();
                this.render();
                this.checkLoops();
            }
            
            clickCell(row, col) {
                if (!this.running || this.paused) return;
                if (!this.board[row][col]) return;
                
                // âœ… v007: æ¶ˆæ»…ä¸­ãƒ–ãƒ­ãƒƒã‚¯å€‹åˆ¥ãƒã‚§ãƒƒã‚¯
                const cellKey = `${row},${col}`;
                if (this.disappearingBlocks.has(cellKey)) return;
                
                const pipe = this.board[row][col];
                const maxRot = pipe.type === 'I' ? 2 : 4;
                pipe.rotation = (pipe.rotation + 1) % maxRot;
                
                // ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
                soundManager.playRotateSound();
                
                this.updatePathColors();
                this.render();
                this.checkLoops();
            }
            
            addBlock() {
                // âœ… v007: ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆåˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ 
                if (!this.canGenerateBlocks) return;
                
                const spiral = this.generateSpiral();
                
                for (const [row, col] of spiral) {
                    if (!this.board[row][col]) {
                        const types = ['I', 'L'];
                        const type = types[Math.floor(Math.random() * types.length)];
                        const maxRot = type === 'I' ? 2 : 4;
                        
                        this.board[row][col] = {
                            type: type,
                            rotation: Math.floor(Math.random() * maxRot),
                            pathColor: undefined,
                            lengthClass: ''
                        };
                        
                        // ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
                        soundManager.playBlockAppearSound();
                        
                        this.updatePathColors();
                        this.render();
                        
                        // ãƒ–ãƒ­ãƒƒã‚¯å‡ºç¾æ™‚ãƒ«ãƒ¼ãƒ—æ¤œå‡º
                        this.checkLoops();
                        
                        return true;
                    }
                }
                
                if (!this.emergencyMode) {
                    this.startEmergencyMode();
                }
                return false;
            }
            
            generateSpiral() {
                const spiral = [];
                const center = Math.floor(this.size / 2);
                spiral.push([center, center]);
                
                let x = center, y = center;
                let dir = 0;
                const dx = [0, 1, 0, -1];
                const dy = [1, 0, -1, 0];
                let steps = 1;
                
                while (spiral.length < this.size * this.size) {
                    for (let i = 0; i < 2; i++) {
                        for (let j = 0; j < steps; j++) {
                            x += dx[dir];
                            y += dy[dir];
                            if (x >= 0 && x < this.size && y >= 0 && y < this.size) {
                                spiral.push([x, y]);
                            }
                        }
                        dir = (dir + 1) % 4;
                    }
                    steps++;
                }
                
                return spiral;
            }
            
            updatePathColors() {
                try {
                    // å…¨ã¦ã®ãƒ‘ã‚¹è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.board[i][j]) {
                                this.board[i][j].pathColor = undefined;
                                this.board[i][j].lengthClass = '';
                            }
                        }
                    }
                    
                    const globalVisited = new Set();
                    
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.board[i][j] && !globalVisited.has(`${i},${j}`)) {
                                const path = this.tracePath(i, j, globalVisited);
                                
                                if (path && path.length > 0) {
                                    // 10æ®µéšè‰²åˆ†ã‘ï¼ˆ10ä»¥ä¸Šã¯èµ¤ã«æˆ»ã‚‹ï¼‰
                                    const pathColor = this.getPathColorId(path.length);
                                    const lengthClass = this.getLengthClass(path.length);
                                    
                                    // ãƒ‘ã‚¹ã®å…¨ã‚»ãƒ«ã«è‰²ãƒ»æ˜ã‚‹ã•ã‚¯ãƒ©ã‚¹ã‚’å‰²ã‚Šå½“ã¦
                                    for (const [row, col] of path) {
                                        if (this.board[row] && this.board[row][col]) {
                                            this.board[row][col].pathColor = pathColor;
                                            this.board[row][col].lengthClass = lengthClass;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('updatePathColors error:', error);
                }
            }
            
            getPathColorId(pathLength) {
                // 10æ®µéšã§å¾ªç’°: 1å€‹=0ã€2å€‹=1ã€...ã€10å€‹=9ã€11å€‹=0ã€12å€‹=1...
                return (pathLength - 1) % 10;
            }
            
            getLengthClass(pathLength) {
                // 10å€‹ä»¥ä¸Šã¯æ˜ã‚‹ãã—ã¦åŒºåˆ¥
                return pathLength >= 10 ? 'length-10plus' : '';
            }
            
            tracePath(startRow, startCol, globalVisited) {
                const path = [];
                const pathSet = new Set();
                
                const dfs = (row, col) => {
                    const key = `${row},${col}`;
                    
                    if (pathSet.has(key) || globalVisited.has(key)) return;
                    if (!this.board[row] || !this.board[row][col]) return;
                    
                    path.push([row, col]);
                    pathSet.add(key);
                    globalVisited.add(key);
                    
                    const connections = this.getConnections(row, col);
                    
                    for (const [nextRow, nextCol] of connections) {
                        if (nextRow >= 0 && nextRow < this.size && nextCol >= 0 && nextCol < this.size) {
                            if (this.isConnected(row, col, nextRow, nextCol)) {
                                dfs(nextRow, nextCol);
                            }
                        }
                    }
                };
                
                dfs(startRow, startCol);
                return path;
            }
            
            checkLoops() {
                const visited = new Set();
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] && !visited.has(`${i},${j}`)) {
                            const loop = this.findLoop(i, j, visited);
                            if (loop.length > 2) {
                                this.removeLoop(loop);
                                return;
                            }
                        }
                    }
                }
            }
            
            findLoop(startRow, startCol, globalVisited) {
                const path = [];
                const pathSet = new Set();
                
                const dfs = (row, col, prevRow, prevCol) => {
                    const key = `${row},${col}`;
                    
                    if (pathSet.has(key)) {
                        const loopStart = path.findIndex(([r, c]) => r === row && c === col);
                        return path.slice(loopStart);
                    }
                    
                    if (globalVisited.has(key) || !this.board[row][col]) {
                        return [];
                    }
                    
                    path.push([row, col]);
                    pathSet.add(key);
                    
                    const connections = this.getConnections(row, col);
                    
                    for (const [nextRow, nextCol] of connections) {
                        if (nextRow === prevRow && nextCol === prevCol) continue;
                        if (nextRow < 0 || nextRow >= this.size || nextCol < 0 || nextCol >= this.size) continue;
                        
                        if (this.isConnected(row, col, nextRow, nextCol)) {
                            const loop = dfs(nextRow, nextCol, row, col);
                            if (loop.length > 0) {
                                return loop;
                            }
                        }
                    }
                    
                    path.pop();
                    pathSet.delete(key);
                    globalVisited.add(key);
                    return [];
                };
                
                return dfs(startRow, startCol, -1, -1);
            }
            
            getConnections(row, col) {
                const pipe = this.board[row][col];
                if (!pipe) return [];
                
                const { type, rotation } = pipe;
                const connections = [];
                
                if (type === 'I') {
                    if (rotation === 0) {
                        connections.push([row - 1, col], [row + 1, col]);
                    } else {
                        connections.push([row, col - 1], [row, col + 1]);
                    }
                } else if (type === 'L') {
                    const lConnections = [
                        [[row, col + 1], [row + 1, col]],
                        [[row, col - 1], [row + 1, col]],
                        [[row, col - 1], [row - 1, col]],
                        [[row, col + 1], [row - 1, col]]
                    ];
                    connections.push(...lConnections[rotation]);
                }
                
                return connections;
            }
            
            isConnected(row1, col1, row2, col2) {
                if (!this.board[row2] || !this.board[row2][col2]) return false;
                
                const connections1 = this.getConnections(row1, col1);
                const connections2 = this.getConnections(row2, col2);
                
                const hasConnection1 = connections1.some(([r, c]) => r === row2 && c === col2);
                const hasConnection2 = connections2.some(([r, c]) => r === row1 && c === col1);
                
                return hasConnection1 && hasConnection2;
            }
            
            removeLoop(loop) {
                // âœ… v007: ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆã‚’ä¸€æ™‚åœæ­¢ï¼ˆæ¶ˆæ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ï¼‰
                this.canGenerateBlocks = false;
                
                // âœ… v007: æ¶ˆæ»…å¯¾è±¡ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç™»éŒ²
                loop.forEach(([row, col]) => {
                    this.disappearingBlocks.add(`${row},${col}`);
                });
                
                const score = loop.length * loop.length;
                this.score += score;
                
                // ãƒã‚¤ã‚¹ã‚³ã‚¢æ›´æ–°ãƒã‚§ãƒƒã‚¯
                const isNewRecord = highScoreManager.setHighScore(this.score);
                if (isNewRecord) {
                    highScoreManager.updateHighScoreDisplay();
                }
                
                // ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
                soundManager.playLoopCompleteSound(loop.length);
                
                this.highlightLoop(loop);
                this.showScorePopup(loop, score);
                
                // é †æ¬¡æ¶ˆæ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ150msé–“éš”ã§éŸ³éŸ¿ã¨åŒæœŸï¼‰
                setTimeout(() => {
                    this.animateSequentialDisappear(loop);
                    
                    const totalAnimationTime = loop.length * 150 + 1200; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“è¨ˆç®—
                    setTimeout(() => {
                        // âœ… v007: æ¶ˆæ»…å®Œäº†å‡¦ç†
                        loop.forEach(([row, col]) => {
                            if (this.board[row]) {
                                this.board[row][col] = null;
                            }
                            // æ¶ˆæ»…ä¸­ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
                            this.disappearingBlocks.delete(`${row},${col}`);
                        });
                        
                        this.updatePathColors();
                        this.render();
                        
                        // âœ… v007: ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆå†é–‹
                        this.canGenerateBlocks = true;
                        
                        if (this.emergencyMode) {
                            this.emergencyTimer = Math.min(this.emergencyTimer + 5, 20);
                            this.emergencyMode = false;
                            
                            // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰è§£é™¤æ™‚ã«è­¦å‘ŠéŸ³åœæ­¢
                            soundManager.stopEmergencySound();
                            
                            if (this.timerInterval) {
                                clearInterval(this.timerInterval);
                            }
                            
                            this.timerInterval = setInterval(() => {
                                if (!this.running || this.paused || this.emergencyMode) return;
                                this.addBlock();
                            }, Math.floor(2000 / this.speedMultiplier));
                        }
                    }, totalAnimationTime);
                }, 600);
            }
            
            highlightLoop(loop) {
                const board = document.getElementById('gameBoard');
                if (!board) return;
                
                for (const [row, col] of loop) {
                    const cellIndex = row * this.size + col;
                    const cell = board.children[cellIndex];
                    if (cell) {
                        cell.classList.add('loop-highlight');
                    }
                }
            }
            
            // âœ… v007: 150msé–“éš”é †æ¬¡æ¶ˆæ»…ï¼ˆéŸ³éŸ¿åŒæœŸï¼‰
            animateSequentialDisappear(loop) {
                const board = document.getElementById('gameBoard');
                if (!board) return;
                
                loop.forEach((position, index) => {
                    const [row, col] = position;
                    
                    setTimeout(() => {
                        const cellIndex = row * this.size + col;
                        const cell = board.children[cellIndex];
                        if (cell) {
                            cell.classList.remove('loop-highlight');
                            cell.classList.add('block-disappear');
                        }
                    }, index * 150); // âœ… 150msé–“éš”ã§éŸ³éŸ¿ã¨å®Œå…¨åŒæœŸ
                });
            }
            
            showScorePopup(loop, score) {
                let centerRow = 0, centerCol = 0;
                for (const [row, col] of loop) {
                    centerRow += row;
                    centerCol += col;
                }
                centerRow = Math.floor(centerRow / loop.length);
                centerCol = Math.floor(centerCol / loop.length);
                
                const board = document.getElementById('gameBoard');
                if (!board) return;
                
                const cellIndex = centerRow * this.size + centerCol;
                const cell = board.children[cellIndex];
                if (!cell) return;
                
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = `+${score}`;
                
                const rect = cell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                
                popup.style.position = 'absolute';
                popup.style.left = `${rect.left - boardRect.left + rect.width/2}px`;
                popup.style.top = `${rect.top - boardRect.top + rect.height/2}px`;
                
                board.appendChild(popup);
                
                setTimeout(() => {
                    if (popup.parentNode) {
                        popup.parentNode.removeChild(popup);
                    }
                }, 1500);
            }
            
            startEmergencyMode() {
                this.emergencyMode = true;
                this.emergencyTimer = 20;
                
                // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆç¶™ç¶šéŸ³ï¼‰
                soundManager.playEmergencySound();
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.timerInterval = setInterval(() => {
                    if (!this.running || this.paused) return;
                    
                    this.emergencyTimer--;
                    
                    if (this.emergencyTimer <= 0) {
                        this.gameOver();
                    }
                }, 1000);
            }
            
            start() {
                this.size = tempSettings.fieldSize;
                this.score = 0;
                this.running = true;
                this.paused = false;
                this.emergencyMode = false;
                this.emergencyTimer = 20;
                this.speedMultiplier = tempSettings.gameSpeed;
                
                // âœ… v007: æ¶ˆæ»…ä¸­ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
                this.canGenerateBlocks = true;
                this.disappearingBlocks.clear();
                
                this.init();
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                this.addBlock();
                this.startBlockTimer();
            }
            
            startBlockTimer() {
                const baseInterval = 2000;
                const interval = Math.floor(baseInterval / this.speedMultiplier);
                
                this.timerInterval = setInterval(() => {
                    if (!this.running || this.paused || this.emergencyMode) return;
                    this.addBlock();
                }, interval);
            }
            
            // âœ… v007: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€Ÿåº¦å¤‰æ›´ï¼ˆéç ´å£Šçš„ï¼‰
            setSpeed(multiplier) {
                this.speedMultiplier = multiplier;
                
                if (this.timerInterval && !this.emergencyMode) {
                    clearInterval(this.timerInterval);
                    this.startBlockTimer();
                }
            }
            
            togglePause() {
                this.paused = !this.paused;
                const btn = document.getElementById('pauseBtn');
                btn.textContent = this.paused ? 'â–¶ï¸' : 'â¸ï¸';
            }
            
            gameOver() {
                this.running = false;
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                // ç·Šæ€¥ãƒ¢ãƒ¼ãƒ‰è­¦å‘ŠéŸ³åœæ­¢
                soundManager.stopEmergencySound();
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çˆ†ç™ºéŸ³
                soundManager.playGameOverSound();
                
                const finalScore = document.getElementById('finalScore');
                if (finalScore) finalScore.textContent = this.score;
                
                const gameOverEl = document.getElementById('gameOver');
                if (gameOverEl) gameOverEl.style.display = 'flex';
            }
        }
        
        function newGame() {
            const gameOverEl = document.getElementById('gameOver');
            if (gameOverEl) gameOverEl.style.display = 'none';
            
            if (game) {
                if (game.timerInterval) {
                    clearInterval(game.timerInterval);
                }
            }
            
            game = new Game();
            game.start();
        }
        
        function togglePause() {
            if (game) {
                game.togglePause();
            }
        }
        
        function resetHighScore() {
            if (confirm('ãƒã‚¤ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                highScoreManager.resetHighScore();
                alert('ãƒã‚¤ã‚¹ã‚³ã‚¢ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
            }
        }
        
        function openSettings() {
            tempSettings.fieldSize = game ? game.size : 11;
            tempSettings.gameSpeed = game ? game.speedMultiplier : 1;
            tempSettings.soundEffects = soundManager.enabled;
            tempSettings.backgroundMusic = soundManager.musicEnabled;
            
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'flex';
            
            updateFieldSizeSelection();
            updateSpeedSelection();
            updateAudioSettings();
            highScoreManager.updateHighScoreDisplay();
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'none';
        }
        
        // âœ… v007: éç ´å£Šçš„è¨­å®šå¤‰æ›´ã‚·ã‚¹ãƒ†ãƒ 
        function applySettings() {
            // ç ´å£Šçš„å¤‰æ›´ï¼ˆã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆå¿…è¦ï¼‰
            if (tempSettings.fieldSize !== (game ? game.size : 11)) {
                if (game) {
                    game.size = tempSettings.fieldSize;
                    game.score = 0; // ã‚¹ã‚³ã‚¢ã‚‚ãƒªã‚»ãƒƒãƒˆ
                    game.init();
                    game.render();
                }
            } else {
                // éç ´å£Šçš„å¤‰æ›´ï¼ˆã‚²ãƒ¼ãƒ ç¶™ç¶šï¼‰
                
                // ã‚²ãƒ¼ãƒ é€Ÿåº¦å¤‰æ›´ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é©ç”¨ï¼‰
                if (game && tempSettings.gameSpeed !== game.speedMultiplier) {
                    game.setSpeed(tempSettings.gameSpeed);
                }
                
                // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®šï¼ˆå³åº§åæ˜ ï¼‰
                if (tempSettings.soundEffects !== soundManager.enabled) {
                    soundManager.setEnabled(tempSettings.soundEffects);
                }
                
                if (tempSettings.backgroundMusic !== soundManager.musicEnabled) {
                    soundManager.setMusicEnabled(tempSettings.backgroundMusic);
                }
            }
            
            closeSettings();
        }
        
        function updateFieldSizeSelection() {
            const options = document.querySelectorAll('.size-option');
            options.forEach(option => {
                option.classList.remove('selected');
                if (parseInt(option.dataset.size) === tempSettings.fieldSize) {
                    option.classList.add('selected');
                }
            });
        }
        
        function updateSpeedSelection() {
            const options = document.querySelectorAll('.speed-option');
            options.forEach(option => {
                option.classList.remove('selected');
                if (parseFloat(option.dataset.speed) === tempSettings.gameSpeed) {
                    option.classList.add('selected');
                }
            });
        }
        
        function updateAudioSettings() {
            document.getElementById('soundEffects').checked = tempSettings.soundEffects;
            document.getElementById('backgroundMusic').checked = tempSettings.backgroundMusic;
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        document.addEventListener('DOMContentLoaded', () => {
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚µã‚¤ã‚ºé¸æŠ
            const sizeOptions = document.querySelectorAll('.size-option');
            sizeOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const size = parseInt(option.dataset.size);
                    tempSettings.fieldSize = size;
                    updateFieldSizeSelection();
                });
            });
            
            // ã‚²ãƒ¼ãƒ é€Ÿåº¦é¸æŠ
            const speedOptions = document.querySelectorAll('.speed-option');
            speedOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const speed = parseFloat(option.dataset.speed);
                    tempSettings.gameSpeed = speed;
                    updateSpeedSelection();
                });
            });
            
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè¨­å®š
            document.getElementById('soundEffects').addEventListener('change', (e) => {
                tempSettings.soundEffects = e.target.checked;
            });
            
            document.getElementById('backgroundMusic').addEventListener('change', (e) => {
                tempSettings.backgroundMusic = e.target.checked;
            });
        });
        
        window.addEventListener('load', () => {
            newGame();
        });
    </script>
</body>
</html>
